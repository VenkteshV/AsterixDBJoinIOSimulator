from enum import Enum
import math
import matplotlib

matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
import os
import shutil

build_size = 1005
probe_size = 1005
F = 1.3
mem = 256
npartitions = 1
numOfJoins = 1
pageTransferTime = 0.2
seekTime = 0.5


class Algo(Enum):
    RDT_FAIR = 1
    RDT_MIN = 2
    RDT_MAX = 3
    LDT = 4


def MBTOPages(MB):
    return int(MB * 1024 * 1024 / 32768)


def pageToMB(pages):
    return int(pages * 32768 / 1024 / 1024)


class partitionInfo():
    def __init__(self, pid, mem, size):
        self.pid = pid
        self.mem = mem
        self.size = size
        self.inMem = 0
        self.RW = 0
        self.SW = 0
        self.seqR = 0  # during build: for brining paritions back at build close
        self.randR = 0
        self.seeks = 0

    def doRW(self, RW):  # randomwrite
        self.RW += int(RW)
        self.seeks += int(RW)

    def doSW(self, SW):
        self.SW += int(SW)
        self.seeks += 1

    def doSR(self):
        self.seqR += self.size
        self.inMem = self.size
        self.seeks += 1

    def print(self):
        print("pid: " + str(self.pid) + " size: " + str(self.size) + " mem: " + str(self.mem) + " SW(pages): " + str(
            self.SW) + " RW: " + str(self.RW) + " inMem: " + str(self.inMem))


class Join():

    def __init__(self, build_size, probe_size, mem, F, nPartitions, partitions):
        self.build = build_size
        self.probe = probe_size
        self.mem = mem
        self.F = F
        self.npartitions = nPartitions
        # self.partitions = self.getNumberOfPartitions()
        self.partitions = partitions
        self.RpartitionObjs = []
        self.SpartitionObjs = []
        self.spilledPartitions = 0
        self.freeMem = self.mem
        self.spilledStatus = [False] * partitions

    # def getNumberOfPartitions(self):
    #     if mem <= 2:
    #         print("Not Possible")
    #     if mem > self.build * F:
    #         return 2
    #     partitions = math.ceil((self.build * self.F / self.npartitions - self.mem) / (self.mem - 1))
    #     partitions = max(partitions, 2)
    #     if partitions > self.mem:
    #         partitions = math.ceil(math.sqrt(self.build * self.F / self.npartitions))
    #         return max(2, min(partitions, self.mem))
    #     return partitions

    def getBuildInfo(self):
        # data size
        size = int(self.build / self.partitions)
        for i in range(self.partitions):
            memForpartitionI = math.floor(
                (self.mem - self.spilledPartitions) / (self.partitions - self.spilledPartitions))
            p = partitionInfo(i, memForpartitionI, size)
            if memForpartitionI < size:
                self.spilledStatus[p.pid] = True
                p.doSW(memForpartitionI)
                if size - memForpartitionI > 0:
                    p.doRW(size - memForpartitionI)
                self.spilledPartitions += 1
            else:
                p.inMem = size
            self.RpartitionObjs.append(p)
        self.bringPartitionsBackinIfPossible()

    def calculateFreeMemory(self):
        FreeMem = self.mem
        for p in self.RpartitionObjs:
            FreeMem -= p.inMem
        return FreeMem - self.spilledPartitions  # saves at least 1 frame for each spilled partition

    def bringPartitionsBackinIfPossible(self):
        self.freeMem = self.calculateFreeMemory()
        for p in self.RpartitionObjs:
            if p.inMem == 0 and p.size < self.freeMem:
                p.doSR()
                self.freeMem -= p.size
                self.spilledStatus[p.pid] = False
            else:
                break
        self.initProbe()

    def initProbe(self):
        for idx, p in enumerate(self.spilledStatus):
            if p == False:  # corresponding build partition is in memory
                self.SpartitionObjs.append(partitionInfo(idx, 0, 0))
            else:
                self.SpartitionObjs.append(partitionInfo(idx, math.floor(self.freeMem / self.spilledPartitions),
                                                         math.floor(self.probe / self.partitions)))
                partition = self.SpartitionObjs[idx]
                size = partition.size
                while size - partition.mem > 0:
                    self.SpartitionObjs[idx].doSW(partition.mem)
                    size -= partition.mem
                if size > 0:
                    self.SpartitionObjs[idx].doRW(size)
                self.SpartitionObjs[idx].size = size
        self.joinPairPartitions()

    def joinPairPartitions(self):
        for idx, p in enumerate(self.spilledStatus):
            if p == False:
                continue
            else:
                # mem,F,nPartitions,partitions
                nextJoin = Join(self.RpartitionObjs[idx].size, self.SpartitionObjs[idx].size, self.mem, self.F,
                                self.npartitions, self.partitions)
                nextJoin.run()

    def run(self):
        self.getBuildInfo()

    def calculateBuildStats(self):
        global seekTime, pageTransferTime
        inMemPartitions = 0
        spilledPartitions = 0
        inDiskSize = 0
        inMemSize = 0
        RandomWMB = 0
        SeqWMB = 0
        SeqRMB = 0
        Seeks = 0
        TotalTime = 0
        for part in self.RpartitionObjs:
            if part.inMem > 0:
                inMemPartitions += 1
                inMemSize += part.inMem
                SeqRMB += part.seqR

            else:
                spilledPartitions += 1
                inDiskSize += part.RW
                RandomWMB += part.RW
                inDiskSize += part.SW
                SeqWMB += part.SW
                Seeks += part.seeks

        TotalTime += (inDiskSize + SeqRMB) * pageTransferTime + Seeks * seekTime
        return inMemPartitions, spilledPartitions, inDiskSize, inMemSize, RandomWMB, SeqWMB, SeqRMB, TotalTime

    def printPStats(self, f):
        inMemPartitions, spilledPartitions, inDiskSize, inMemSize, RandomWMB, SeqWMB, SeqR, TotalTime = self.calculateBuildStats()
        print(str(len(self.RpartitionObjs)) + "\t" + str(pageToMB(SeqWMB)) + "\t" + str(pageToMB(RandomWMB)))
        f.write(
            str(len(self.RpartitionObjs)) + "\t" + str(pageToMB(SeqWMB)) + "\t" + str(pageToMB(RandomWMB)) + "\t" + str(
                pageToMB(inDiskSize)) + "\t" + str(TotalTime) + "\n")

    def printBuildStats(self, f):
        inMemPartitions, spilledPartitions, inDiskSize, inMemSize, RandomWMB, SeqWMB, SeqR, TotalTime = self.calculateBuildStats()
        string = str(pageToMB(self.build)) + "\t" + str(pageToMB(SeqWMB)) + "\t" + str(
            pageToMB(RandomWMB)) + "\t" + str(pageToMB(inDiskSize)) + "\t" + str(TotalTime) + "\t" + str(pageToMB(SeqR))
        print(string)
        f.write(string + "\n")


def buildPlotInfo(f):
    line = f.readline()
    x = []
    seq = []
    rand = []
    totalW = []
    totalT = []
    totalR = []
    while (line):
        values = line.strip().split()
        x.append(int(values[0]))
        seq.append(int(values[1]))
        rand.append(int(values[2]))
        totalW.append(int(values[3]))
        totalT.append(float(values[4]))
        totalR.append(float(values[5]))
        line = f.readline()
    return x, seq, rand, totalW, totalT, totalR


def draw(f, xlabel, ylabel, title, xticks, yticks):
    x, seq, rand, totalW, totalT = buildPlotInfo(f)
    #######SeqW
    plt.figure()
    plt.subplot(4, 1, 1)
    plt.step(x, seq, label="SeqW")
    plt.ylim(bottom=0, top=max(seq) + 100)
    plt.xlim(left=0)
    # plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    if xticks:
        plt.xticks(x, x)
    if yticks:
        plt.yticks(seq, seq)
    plt.grid()
    plt.title(title)
    plt.legend()
    plt.show()
    ########RandW
    plt.subplot(4, 1, 2)
    plt.step(x, rand, label="RandW")
    plt.ylim(bottom=0, top=max(rand) + 100)
    plt.xlim(left=0)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    if xticks:
        plt.xticks(x, x)
    if yticks:
        plt.yticks(rand, rand)
    plt.grid()
    plt.legend()
    plt.show()
    ##############TotalW
    plt.subplot(4, 1, 3)
    plt.step(x, totalW, label="TotalW")
    plt.ylim(bottom=0, top=max(totalW) + 100)
    plt.xlim(left=0)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    if xticks:
        plt.xticks(x, x)
    if yticks:
        plt.yticks(rand, rand)
    plt.grid()
    plt.legend()
    plt.show()
    ##############TotalTime
    plt.subplot(4, 1, 4)
    plt.step(x, totalT, label="TotalTime")
    plt.ylim(bottom=0, top=max(totalT) + 100)
    plt.xlim(left=0)
    plt.xlabel(xlabel)
    plt.ylabel("Time(ms)")
    if xticks:
        plt.xticks(x, x)
    if yticks:
        plt.yticks(rand, rand)
    plt.grid()
    plt.legend()
    plt.tight_layout()
    plt.show()
    return plt


def drawSeparate(f, xlabel, ylabel, title, xaxistext, xticks, yticks, sufix):
    if os.path.exists("./Partition" + sufix):
        shutil.rmtree("./Partition" + sufix)
    try:
        os.mkdir("./Partition" + sufix)
    except OSError:
        print("Creation of the directory %s failed" % sufix)
    x, seq, rand, totalW, totalT, totalR = buildPlotInfo(f)
    plt.clf()
    plt.step([1, 2, 3, 4], seq, label="SeqW", marker="d", where='post')
    plt.ylim(bottom=0, top=1.5 * max(seq))
    plt.xlim(left=0)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    if xticks:
        plt.xticks([1, 2, 3, 4], xaxistext)
    if yticks:
        plt.yticks(seq, seq)
    plt.grid()
    plt.title(title)
    plt.legend()
    plt.savefig("./Partition" + sufix + "/SeqW.png")
    ########RandW
    plt.clf()
    plt.step([1, 2, 3, 4], rand, label="RandW", marker="d", where='post')
    plt.ylim(bottom=0, top=1.5 * max(rand))
    plt.xlim(left=0)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    if xticks:
        plt.xticks([1, 2, 3, 4], xaxistext)
    if yticks:
        plt.yticks(rand, rand)
    plt.grid()
    plt.title(title)
    plt.legend()
    plt.savefig("./Partition" + sufix + "/RandW.png")
    ##############TotalW
    plt.clf()
    plt.step([1, 2, 3, 4], totalW, label="TotalW", marker="d")
    plt.ylim(bottom=0, top=1.5 * max(totalW))
    plt.xlim(left=0)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    if xticks:
        plt.xticks([1, 2, 3, 4], xaxistext)
    if yticks:
        plt.yticks(totalW, totalW)
    plt.grid()
    plt.title(title)
    plt.legend()
    plt.savefig("./Partition" + sufix + "/TotalW.png")
    ##############TotalTime
    plt.clf()
    plt.step([1, 2, 3, 4], totalT, label="TotalTime", marker="d")
    plt.ylim(bottom=0, top=1.5 * max(totalT))
    plt.xlim(left=0)
    plt.xlabel(xlabel)
    plt.ylabel("Total Time(ms)")
    if xticks:
        plt.xticks([1, 2, 3, 4], xaxistext)
    if yticks:
        plt.yticks(totalT, totalT)
    plt.grid()
    plt.legend()
    plt.title(title)
    plt.tight_layout()
    plt.savefig("./Partition" + sufix + "/TotalTime.png")

    ##############TotalRead
    if max(totalR) > 0:
        plt.clf()
        plt.step([1, 2, 3, 4], totalR, label="SeqR", marker="d")
        plt.ylim(bottom=0, top=1.5 * max(totalR))
        plt.xlim(left=0)
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)
        if xticks:
            plt.xticks([1, 2, 3, 4], xaxistext)
        if yticks:
            plt.yticks(totalR, totalR)
        plt.grid()
        plt.title(title)
        plt.legend()
        plt.savefig("./Partition" + sufix + "/SeqR.png")


def partitionIsVar():
    f = open("./pstats.txt", "w+")
    for i in range(2, 101):
        join = Join(build_size, mem, F, npartitions, i)
        join.run()
        join.printPStats(f)
    f.close()
    f = open("./pstats.txt", "r")
    plt = draw(f, "partitions", "Writes(MB)", "", False, False)
    plt.show()
    f.close()


def buildSizeIsVar():
    global probe_size
    # buildSize = [32,64, 128, 256, 512, 1024, 2048]
    # for i in range(10,2048,10):
    #     buildSize.append(i)
    # XS => buildsize = 0.7 * Mem #fits in memory
    # S => buildsize = 1.1 * M
    # M => buildsize = 4 * M #2rounds
    # L => buildsize  = avg(pow(Mem,2),pow(Mem,3) # 3rounds
    # XL => buildsize = avg(pow(Mem,3),pow(Mem,4)) # 4rounds or more

    # buildsizeToMemeoryRatio=[0.7*mem, 1.1*mem, 4*mem, (math.pow(mem,2)+math.pow(mem,3))/2 ,(math.pow(mem,3)+math.pow(mem,4))/2 ]
    buildsizeToMemeoryRatio = [0.7 * mem, 1.1 * mem, 4 * mem, 50 * mem]
    # buildsizeToMemeoryRatio = [1.1 * mem]
    buildSize = []
    for i in buildsizeToMemeoryRatio:
        buildSize.append(math.ceil(i))
    buildSize.sort()
    print("Build Size: " + str(buildSize))
    for partition in range(2, 101):
        print("================================Partitions = " + str(partition) + " | Mem = " + str(
            mem) + " (MB) =========================================")
        print("builsSize, seqW, randW, TotalW, TotalTime, seqR")
        f = open("./bstats.txt", "w+")
        for bs in buildSize:
            join = Join(MBTOPages(bs), MBTOPages(bs), MBTOPages(mem) - 2, F, npartitions,
                        partition)  # so far build_size and probe_size are set to be the same value change with probe_size if needed.
            join.run()
            join.printBuildStats(f)
        f.close()
        f = open("./bstats.txt", "r")

        # draw(f,"Build Size(MB)","Writes(MB)"," Partitions = "+str(len(join.partitionObjs))+" Memory = "+str(mem)+" (MB)", False,False).savefig("./partition"+str(i)+".png")
        # draw(f, "Build Size(MB)", "Writes(MB)",
        #      " Partitions = " + str(len(join.partitionObjs)) + " Memory = " + str(mem) + " (MB)", False, False).show()

        drawSeparate(f, "Build Size Class", "Writes(MB)",
                     " Partitions = " + str(len(join.RpartitionObjs)) + " Memory = " + str(mem) + " (MB)",
                     ["XS(0.7*Mem)", "S(1.1*Mem)", "M(4*Mem)", "L(50*Mem)"], True, False, str(partition))
        plt.clf()
        f.close()


# partitionIsVar()

buildSizeIsVar()